# fraud_detection 5

> **Warning:** The `.cargo/` folder contains Windows-specific configuration (custom `target-dir` for OneDrive, CPU flags). Delete or rename before building:
> ```bash
> mv .cargo .cargo.bak
> ```
> More information on this [page](https://www.40tude.fr/docs/06_programmation/rust/005_my_rust_setup_win11/my_rust_setup_win11.html#onedrive).


## Description

- My first attempt to use [Spec Kit](https://github.com/github/spec-kit) and SDD.
- The application simulates a fraud detection system
    - Transactions are generated by Provider and written in Buffer1
    - Consumer extracts the transactions, send them to the Modelizer which returns inferred_transaction
    - On return, for each fraudulent inferred_transaction an alarm is sent
    - inferred_transaction are written in Buffer2
    - Logger extract inferred_transaction and writes pending_transaction in Storage
        - pending_transaction is a inferred_transaction + is_reviewed + actual_fraud
        - the fields will be set once the transaction will be checked
        - Storage's content can be used to train a ML model with recent data
- Extractions and Writes operate on batches of transactions
    - Batches size vary
    - Speeds are all different
- The application is a modular monolith
- Every component
    - use an hexagonal architecture
    - DIP is used to decouple components from implementation of buffers and storage
    - Run asynchronously (tokio)
    - Use thiserror


<div align="center">
<img src="./docs/fig_00.png" alt="" width="700" loading="lazy"/><br/>
<!-- <span>Optional comment</span> -->
</div>


## Installation

```bash
cargo clean
cargo build
cargo build --release
```

## Usage

```bash
$env:RUST_LOG='info'; cargo run --bin fraud_detection; Remove-Item env:RUST_LOG
cargo run --bin fraud_detection
# CTRL + C to stop


$env:RUST_LOG='info'; cargo run --bin fraud_detection_sqlite; Remove-Item env:RUST_LOG
# fraud_detection.db created in current directory; rows visible in any SQLite browser
# CTRL + C to stop


cargo run --bin fraud_detection_bench --release

# Expected output
bench: ITERATIONS=1000  ROUNDS=5  (storage cost excluded)
batch_size |   total_tx |   min tx/s |   avg tx/s |   max tx/s
-----------+------------+------------+------------+-----------
     1 000 |    500 023 |     64 833 |     89 813 |    100 354
     2 000 |  1 007 116 |    181 068 |    191 257 |    199 450
     5 000 |  2 448 551 |    460 934 |    520 271 |    584 225
    10 000 |  4 947 288 |  1 039 562 |  1 143 706 |  1 236 119
    20 000 |  9 988 180 |  1 745 324 |  1 879 779 |  1 946 497
    50 000 | 25 576 582 |  2 627 521 |  2 691 132 |  2 793 828
   100 000 | 49 855 712 |  3 539 772 |  3 870 567 |  4 027 985

# - The spread on 1,000 is atypical (64k min vs. 100k max = 55%), while the other sizes are at ~10-15%. This is a classic “cold start” effect—the first round of the first batch size pays the startup cost of the Tokio runtime + initial memory allocation. Subsequent rounds are stable.
# - Variance < 10% across all sizes -- stable measurements - No visible saturation: the curve still rises to 100k (3.6M avg), the pipeline has not reached its ceiling
# - Release/debug ratio: ~3.5x for small batches, ~4.7x for large batches -- the compiler optimizes hot loops well (UUID gen, rand, Vec::drain)
# - Curve knee between 10k and 20k: gain from 1.2M to 1.9M (+58%) then slowdown at 50k (+44%) -- suggests that the tokio yield_now overhead becomes dominant at small batches, and that CPU saturation approaches around 50-100k

```

## Testing

```bash
cargo test
```

## License

MIT License - see [LICENSE](LICENSE) for details


## Contributing
This project is developed for personal and educational purposes. Feel free to explore and use it to enhance your own learning.

Given the nature of the project, external contributions are not actively sought nor encouraged. However, constructive feedback aimed at improving the project (in terms of speed, accuracy, comprehensiveness, etc.) is welcome. Please note that this project is being created as a hobby and is unlikely to be maintained once my initial goal has been achieved.
