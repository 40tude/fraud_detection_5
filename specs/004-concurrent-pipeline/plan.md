# Implementation Plan: Concurrent Pipeline

**Branch**: `004-concurrent-pipeline` | **Date**: 2026-02-23 | **Spec**: `specs/004-concurrent-pipeline/spec.md`
**Input**: Feature specification from `/specs/004-concurrent-pipeline/spec.md`

## Summary

Refactor `main.rs` to run Producer and Consumer concurrently via `tokio::join!`
inside `tokio::select!` with CTRL+C graceful shutdown (FR-001 through FR-009).
Introduce a new `ConcurrentBuffer` adapter that yields on empty reads, enabling
true cooperative async interleaving without breaking any existing test.

## Technical Context

**Language/Version**: Rust 1.85 (edition 2024)
**Primary Dependencies**: tokio 1.x (rt, macros, time, signal), log 0.4, anyhow 1
**Storage**: N/A (in-memory only)
**Testing**: cargo test --workspace
**Target Platform**: Windows 11, single-thread Tokio runtime (current_thread)
**Project Type**: binary (fraud_detection) + library crates (workspace)
**Performance Goals**: Cooperative async interleaving; no throughput target for PoC
**Constraints**: All 55 existing tests must pass; no Producer/Consumer API changes
**Scale/Scope**: PoC pipeline with 2 concurrent async tasks

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

| Principle | Check | Notes |
|-----------|-------|-------|
| I. Hexagonal Architecture | PASS | ConcurrentBuffer implements Buffer1 + Buffer1Read traits; no concrete deps cross boundaries |
| II. Modular Monolith | PASS | Changes confined to binary crate (`fraud_detection`) and internal behavior of producer/consumer; no new crate |
| III. TDD (NON-NEGOTIABLE) | PASS | ConcurrentBuffer tests written before implementation per Red-Green-Refactor |
| IV. Pedagogical Clarity | PASS | select!/join! pattern is explicit and self-documenting; close() is a direct method call |
| V. Async Pipeline | PASS | Both components run asynchronously; batch sizes unchanged |
| VI. Concurrent Component Lifecycle | PASS | tokio::join! on current_thread; ctrl_c via tokio::signal; buffer closure as stop signal |

**Post-design re-check**: All six principles satisfied. No violations to justify.

## Project Structure

### Documentation (this feature)

```text
specs/004-concurrent-pipeline/
├── plan.md              # This file
├── research.md          # Phase 0 decisions
├── data-model.md        # Phase 1 -- ConcurrentBuffer state model
├── quickstart.md        # Phase 1 -- run / test instructions
└── tasks.md             # Phase 2 -- generated by /speckit.tasks
```

### Source Code (affected files)

```text
Cargo.toml                                          # add tokio "signal" feature
crates/producer/src/lib.rs                          # add FR-009 iteration-limit log
crates/consumer/src/lib.rs                          # add FR-009 iteration-limit log
crates/fraud_detection/src/adapters/mod.rs          # add pub mod concurrent_buffer
crates/fraud_detection/src/adapters/concurrent_buffer.rs  # NEW adapter
crates/fraud_detection/src/main.rs                  # refactor to concurrent pattern
```

No new crates. No changes to `crates/domain/`, `crates/modelizer/`, or any
other adapter in `fraud_detection` (in_memory_buffer, in_memory_buffer2,
demo_model, log_alarm).

## Implementation Strategy

### Phase A -- Dependency & adapter (enables compilation)

1. Add `"signal"` to tokio workspace features (`Cargo.toml`).
2. Create `ConcurrentBuffer` adapter (TDD: write tests first, then impl).
3. Register `pub mod concurrent_buffer` in `adapters/mod.rs`.

### Phase B -- FR-009 log completions (independent, no risk)

4. Add `log::info!("producer.run.stopped: iteration limit...")` in `producer/src/lib.rs`.
5. Add `log::info!("consumer.run.stopped: iteration limit...")` in `consumer/src/lib.rs`.

### Phase C -- main.rs refactor (depends on Phase A)

6. Replace sequential producer/consumer calls with:
   ```rust
   let producer_task = async {
       let r = producer.run(&buffer1).await;
       buffer1.close();  // close after finite run completes
       r
   };
   tokio::select! {
       _ = tokio::signal::ctrl_c() => {
           log::info!("main.shutdown: ctrl_c received, closing buffer");
           buffer1.close();
       }
       (p, c) = tokio::join!(producer_task, consumer.run(&buffer1, ...)) => {
           p.context("producer failed")?;
           c.context("consumer failed")?;
       }
   }
   Ok(())
   ```
7. Remove iteration limit from `ProducerConfig` in `main.rs` (infinite by default).
8. Set `poll_interval2` to a nonzero value (e.g., 25 ms) so Consumer yields regularly.

### Phase D -- Validate

9. `cargo test --workspace` -- all 55 tests must pass.
10. Manual run: verify interleaved log output.

## Key Design Decisions (from research.md)

| Decision | Chosen | Rejected alternative |
|----------|--------|---------------------|
| Buffer for concurrent mode | New `ConcurrentBuffer` adapter | Modify `InMemoryBuffer` (breaks FR-008) |
| Empty buffer behavior | `yield_now()` + retry loop | Return `Ok([])` (noisy), `Notify` (adds complexity) |
| CTRL+C shutdown | `select!` ctrl_c arm, drop join! | Loop + `&mut pipeline_fut` (overly complex) |
| Finite shutdown | Wrapper closes buffer after `producer.run()` | Add `close()` to `Buffer1` trait (breaks FR-008) |
| CTRL+C wait strategy | Cancel-on-ctrl_c (simplest) | Drain-then-exit (complex; not required by spec) |

## ConcurrentBuffer Contract

```rust
// Inner state
struct ConcurrentBufferInner {
    data: Vec<Transaction>,
    closed: bool,
}

// Public API
impl ConcurrentBuffer {
    pub fn new() -> Self
    pub fn close(&self)        // sets closed = true; idempotent
}

// write_batch: Err(Closed) if closed, else appends
// read_batch:  if data -> return; if empty+open -> yield, retry; if empty+closed -> Err(Closed)
```

## Test Coverage Plan (ConcurrentBuffer)

| Test ID | Scenario |
|---------|----------|
| CB-T01 | `write_batch` stores data; `read_batch` returns it |
| CB-T02 | `read_batch` on empty+closed returns `Err(Closed)` |
| CB-T03 | `write_batch` on closed buffer returns `Err(Closed)` |
| CB-T04 | `read_batch` drains from front; subsequent read gets next batch |
| CB-T05 | `close()` is idempotent (double-close does not panic) |
| CB-T06 | Concurrent scenario: producer writes, consumer reads (yield unblocks) |

## Complexity Tracking

No Constitution violations. No complexity justification required.

## Unresolved Questions

- None. All clarifications answered in `spec.md#Clarifications`.
