# Implementation Plan: Producer -- Transaction Generation

**Branch**: `001-producer-transactions` | **Date**: 2026-02-22 | **Spec**: [spec.md](spec.md)
**Input**: Feature specification from `/specs/001-producer-transactions/spec.md`

## Summary

Implement the Producer component as a library crate that generates random transaction
batches and writes them to Buffer1 via a hexagonal port (trait). The shared `domain`
crate defines `Transaction`, `BufferError`, and the `Buffer1` trait. The binary crate
`fraud_detection` owns the `InMemoryBuffer` adapter. All inter-component communication
is async. Error handling: `thiserror` in libs, `anyhow` in binary. Logging: `log`
facade in libs, `env_logger` in binary.

## Technical Context

**Language/Version**: Rust 1.93.1, edition 2024
**Primary Dependencies**: `thiserror` 2, `log` 0.4, `env_logger` 0.11, `anyhow` 1,
`uuid` 1, `rand` 0.9, `tokio` 1 (rt, macros, time)
**Storage**: N/A (in-memory buffer for this feature)
**Testing**: `cargo test --workspace`, TDD (red-green-refactor), `#[tokio::test]`
**Target Platform**: Windows 11 (x86_64-pc-windows-msvc)
**Project Type**: Cargo workspace (3 lib crates + 1 binary crate)
**Performance Goals**: N/A for this feature (throughput evaluation deferred to full pipeline)
**Constraints**: Edition 2024, ms-rust compliance, strict clippy lints
**Scale/Scope**: 3 crates, ~500 LOC estimated

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### Pre-Phase 0 Gate

| # | Principle | Status | Evidence |
|---|-----------|--------|----------|
| I | Hexagonal Architecture + DI | PASS | `Buffer1` trait in `domain`; `Producer` depends on trait, not concrete adapter; `InMemoryBuffer` adapter in binary crate |
| II | Modular Monolith (Workspace) | PASS | Workspace with `domain`, `producer`, `fraud_detection` crates; inter-crate deps via domain traits |
| III | TDD (non-negotiable) | PASS | Task generation will enforce red-green-refactor per unit of behavior |
| IV | Pedagogical Clarity | PASS | Plain structs, explicit traits, no proc macros beyond standard derives; comments explain "why" |
| V | Async Pipeline + Variable Batching | PASS | AFIT on `Buffer1`, tokio runtime, batch size randomized per iteration in [1, N1_MAX] |

### Post-Phase 1 Gate (design review)

| # | Principle | Status | Evidence |
|---|-----------|--------|----------|
| I | Hexagonal Architecture + DI | PASS | data-model.md: `Buffer1` trait contract defined; `Producer` takes `impl Buffer1` generic; no concrete dependency |
| II | Modular Monolith (Workspace) | PASS | 3 crates with clear boundaries; domain owns shared types; producer owns domain logic; binary owns adapters |
| III | TDD (non-negotiable) | PASS | All entities testable in isolation; `InMemoryBuffer` serves as test adapter |
| IV | Pedagogical Clarity | PASS | Builder pattern for config; named error variants; no magic; entity relationships documented |
| V | Async Pipeline + Variable Batching | PASS | `write_batch` is async; batch size is `rng.random_range(1..=n1_max)` per iteration |

**Gate result**: ALL PASS -- no violations, no complexity tracking needed.

## Project Structure

### Documentation (this feature)

```text
specs/001-producer-transactions/
├── plan.md              # This file
├── research.md          # Phase 0: dependency + design decisions
├── data-model.md        # Phase 1: entities, traits, relationships
├── quickstart.md        # Phase 1: build/run/test instructions
├── contracts/
│   └── buffer1-trait.md # Phase 1: Buffer1 trait contract
├── checklists/
│   └── requirements.md  # Pre-existing spec quality checklist
└── tasks.md             # Phase 2: generated by /speckit.tasks
```

### Source Code (repository root)

```text
Cargo.toml                              # workspace manifest + [workspace.lints]
.cargo/config.toml                      # target-dir redirect + native CPU flags
crates/
  domain/
    Cargo.toml                          # deps: uuid, thiserror, log, tokio
    src/
      lib.rs                            # Transaction, BufferError, Buffer1 trait
  producer/
    Cargo.toml                          # deps: domain, rand, thiserror, log, tokio
    src/
      lib.rs                            # Producer, ProducerConfig, ProducerConfigBuilder, ProducerError
  fraud_detection/
    Cargo.toml                          # deps: domain, producer, anyhow, env_logger, log, tokio
    src/
      main.rs                           # #[tokio::main], env_logger::init(), wiring
      adapters/
        mod.rs                          # pub mod in_memory_buffer;
        in_memory_buffer.rs             # InMemoryBuffer: Buffer1 impl
```

**Structure Decision**: Cargo workspace with `crates/` directory. Each pipeline
component is a library crate. The binary crate (`fraud_detection`) is the orchestrator
and owns all adapters. This matches Constitution principles I (hex arch) and II
(modular monolith).

## Design Decisions

### D1: Workspace Dependency Management

All shared dependencies declared in `[workspace.dependencies]` in root `Cargo.toml`.
Crates reference via `dep.workspace = true`. Ensures version consistency.

### D2: Workspace Lint Configuration

Root `Cargo.toml` defines `[workspace.lints.clippy]` and `[workspace.lints.rust]` per
ms-rust M-STATIC-VERIFICATION. Each crate inherits via `[lints] workspace = true`.
Key lints: `clippy::pedantic`, `clippy::nursery` at warn level; selected restrictive
lints enabled individually.

### D3: Transaction as Plain Data Carrier

`Transaction` has all public fields. No constructor validation -- constraints are
enforced at generation time by `Producer`. This keeps `Transaction` simple and
forward-compatible (future features add fields without breaking construction).

### D4: ProducerConfig Builder

`ProducerConfig::builder(n1_max)` -- `n1_max` is mandatory (passed to builder
constructor), all other fields have defaults. `build()` validates and returns
`Result<ProducerConfig, ProducerError>`. This follows ms-rust M-INIT-BUILDER.

### D5: Producer Generic Over Buffer

`Producer` takes `B: Buffer1` as generic parameter (not trait object). Static
dispatch, zero overhead. Matches hexagonal architecture with DI.

### D6: Error Propagation Chain

```text
BufferError (domain) --#[from]--> ProducerError (producer) --?--> anyhow::Error (binary)
```

Library crates: typed errors via `thiserror`. Binary crate: `anyhow` for ergonomic `?`.

### D7: Logging Convention

Library crates use `log::{info, warn, debug}` macros:
- `info!` for batch write events (iteration count, batch size)
- `warn!` for backpressure events (buffer full)
- `debug!` for per-transaction details

Binary crate initializes `env_logger::init()` before any async work.

## Complexity Tracking

> No violations found -- table not needed.

## Generated Artifacts

| Artifact | Path | Status |
|----------|------|--------|
| research.md | `specs/001-producer-transactions/research.md` | Complete |
| data-model.md | `specs/001-producer-transactions/data-model.md` | Complete |
| buffer1-trait.md | `specs/001-producer-transactions/contracts/buffer1-trait.md` | Complete |
| quickstart.md | `specs/001-producer-transactions/quickstart.md` | Complete |
| tasks.md | `specs/001-producer-transactions/tasks.md` | Pending `/speckit.tasks` |

## Unresolved Questions

None -- all clarifications resolved in research.md.
